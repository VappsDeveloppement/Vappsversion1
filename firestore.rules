/**
 * @fileOverview Firestore Security Rules for VApps Success Hub.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for personal data and employs role-based access control for administrative functions. It prioritizes security and maintainability through clear, modular rules.
 *
 * Data Structure:
 * - /users/{userId}: Stores personal user profile data. Access is restricted to the owning user.
 * - /appointments/{appointmentId}: Stores appointment data. Access is granted to the coach and client involved in the appointment.
 * - /email_campaigns/{emailCampaignId}: Stores email campaign data. Access is open for prototyping.
 * - /messages/{messageId}: Stores messages. Access is granted to the sender and receiver.
 * - /invoices/{invoiceId}: Stores invoice data. Access is granted to the client associated with the invoice.
 * - /consents/{consentId}: Stores user consent data. Access is restricted to the owning user.
 * - /landing_pages/{landingPageId}: Stores landing page configurations. Access is open for prototyping.
 * - /roles_admin/{userId}: Indicates admin role. The presence of a document grants admin privileges to the corresponding user.
 *
 * Key Security Decisions:
 * - User data is strictly controlled, with each user only able to access their own information.
 * - Listing of user documents is explicitly denied to prevent information leakage.
 * - Data model allows for straightforward role assignment using the /roles_admin collection.
 * - Email campaigns and landing pages currently have open access for prototyping, but should be secured in production.
 *
 * Denormalization for Authorization:
 * - The /appointments collection includes both 'coachId' and 'clientId' fields on each document. This denormalization allows security rules to quickly verify whether the requesting user is either the coach or the client for a given appointment, without needing to perform additional reads.
 * - The /messages collection includes both 'senderId' and 'receiverId' fields on each document. This denormalization allows security rules to quickly verify whether the requesting user is either the sender or the receiver for a given message, without needing to perform additional reads.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Enforces user-ownership for user profiles. Only the authenticated user can read/write their own profile.
     * @path /users/{userId}
     * @allow (create) User A with id 'user_a' can create /users/user_a
     * @allow (get) User A with id 'user_a' can get /users/user_a
     * @allow (update) User A with id 'user_a' can update /users/user_a
     * @allow (delete) User A with id 'user_a' can delete /users/user_a
     * @deny (create) User B with id 'user_b' cannot create /users/user_a
     * @deny (get) User B with id 'user_b' cannot get /users/user_a
     * @deny (update) User B with id 'user_b' cannot update /users/user_a
     * @deny (delete) User B with id 'user_b' cannot delete /users/user_a
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Listing users is not permitted.
      allow create: if isOwner(userId);
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id; // Enforce immutability of userId
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to appointment data. Allows coaches and clients involved in the appointment to read data.
     * @path /appointments/{appointmentId}
     * @allow (get) User A (coach) can get /appointments/appointment_1 if coachId is user_a
     * @allow (get) User B (client) can get /appointments/appointment_1 if clientId is user_b
     * @allow (create) Any authenticated user can create an appointment.
     * @allow (update) Any authenticated user can update an appointment.
     * @allow (delete) Any authenticated user can delete an appointment.
     * @deny (get) User C (not involved) cannot get /appointments/appointment_1
     * @principle Grants access to coaches and clients based on appointment membership.
     */
    match /appointments/{appointmentId} {
      function isParticipant(coachId, clientId) {
        return request.auth.uid == coachId || request.auth.uid == clientId;
      }

      allow get: if isParticipant(resource.data.coachId, resource.data.clientId);
      allow list: if true; // Allowing listing for all users
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Controls access to email campaign data.  Currently open for prototyping, but needs to be secured.
     * @path /email_campaigns/{emailCampaignId}
     * @allow (get) Any authenticated user can get any email campaign.
     * @allow (create) Any authenticated user can create an email campaign.
     * @allow (update) Any authenticated user can update an email campaign.
     * @allow (delete) Any authenticated user can delete any email campaign.
     * @principle Open access for prototyping.  This will need to be secured.
     */
    match /email_campaigns/{emailCampaignId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Controls access to message data. Allows senders and receivers to read messages.
     * @path /messages/{messageId}
     * @allow (get) User A (sender) can get /messages/message_1 if senderId is user_a
     * @allow (get) User B (receiver) can get /messages/message_1 if receiverId is user_b
     * @allow (create) Any authenticated user can create a message.
     * @allow (update) Any authenticated user can update a message.
     * @allow (delete) Any authenticated user can delete a message.
     * @deny (get) User C (not involved) cannot get /messages/message_1
     * @principle Grants access to message participants based on message membership.
     */
    match /messages/{messageId} {
      function isMessageParticipant(senderId, receiverId) {
        return request.auth.uid == senderId || request.auth.uid == receiverId;
      }

      allow get: if isMessageParticipant(resource.data.senderId, resource.data.receiverId);
      allow list: if true; // Allowing listing for all users
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Controls access to invoice data. Allows clients to read their invoices.
     * @path /invoices/{invoiceId}
     * @allow (get) User A can get /invoices/invoice_1 if clientId is user_a
     * @allow (create) Any authenticated user can create an invoice.
     * @allow (update) Any authenticated user can update an invoice.
     * @allow (delete) Any authenticated user can delete an invoice.
     * @deny (get) User B cannot get /invoices/invoice_1 if clientId is not user_b
     * @principle Grants access to invoice based on client ownership.
     */
    match /invoices/{invoiceId} {
      function isInvoiceOwner(clientId) {
        return request.auth.uid == clientId;
      }

      allow get: if isInvoiceOwner(resource.data.clientId);
      allow list: if true; // Allowing listing for all users
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Enforces user-ownership for consent data. Only the authenticated user can read/write their own consent records.
     * @path /consents/{consentId}
     * @allow (create) User A can create /consents/consent_1 if userId is user_a
     * @allow (get) User A can get /consents/consent_1 if userId is user_a
     * @allow (update) User A can update /consents/consent_1 if userId is user_a
     * @allow (delete) User A can delete /consents/consent_1 if userId is user_a
     * @deny (create) User B cannot create /consents/consent_1 if userId is user_a
     * @deny (get) User B cannot get /consents/consent_1 if userId is user_a
     * @deny (update) User B cannot update /consents/consent_1 if userId is user_a
     * @deny (delete) User B cannot delete /consents/consent_1 if userId is user_a
     * @principle Enforces document ownership for writes.
     */
    match /consents/{consentId} {
      function isConsentOwner(userId) {
        return request.auth.uid == userId;
      }

      allow get: if isConsentOwner(resource.data.userId);
      allow list: if true; // Allowing listing for all users
      allow create: if isSignedIn();
      allow update: if isSignedIn() && resource != null;
      allow delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Controls access to landing page configurations. Currently open for prototyping, but needs to be secured.
     * @path /landing_pages/{landingPageId}
     * @allow (get) Any authenticated user can get any landing page.
     * @allow (create) Any authenticated user can create any landing page.
     * @allow (update) Any authenticated user can update any landing page.
     * @allow (delete) Any authenticated user can delete any landing page.
     * @principle Open access for prototyping.  This will need to be secured.
     */
    match /landing_pages/{landingPageId} {
      allow get, list: if true;
      allow create, update, delete: if isSignedIn() && resource != null;
    }

    /**
     * @description Grants admin privileges to users with a document in this collection. Existence of the document is the indicator. DO NOT store user data in this document - existence is the indicator.
     * @path /roles_admin/{userId}
     * @allow (get) User A with id 'user_a' can get /roles_admin/user_a
     * @allow (create) User A with id 'user_a' can create /roles_admin/user_a
     * @allow (update) User A with id 'user_a' can update /roles_admin/user_a
     * @allow (delete) User A with id 'user_a' can delete /roles_admin/user_a
     * @deny (create) User B with id 'user_b' cannot create /roles_admin/user_a
     * @deny (get) User B with id 'user_b' cannot get /roles_admin/user_a
     * @deny (update) User B with id 'user_b' cannot update /roles_admin/user_a
     * @deny (delete) User B with id 'user_b' cannot delete /roles_admin/user_a
     * @principle Role based Access Control.
     */
    match /roles_admin/{userId} {
       function isAdmin(userId) {
        return request.auth.uid == userId;
      }

      function isExistingAdmin(userId) {
        return isAdmin(userId) && resource != null;
      }
      allow get: if isAdmin(userId);
      allow list: if false; // Listing admins is not permitted.
      allow create: if isAdmin(userId);
      allow update: if isExistingAdmin(userId);
      allow delete: if isExistingAdmin(userId);
    }

    function isSignedIn() {
      return request.auth != null;
    }
  }
}